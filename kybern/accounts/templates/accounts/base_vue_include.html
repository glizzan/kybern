<!-- App-wide scripts. -->
<script type="application/javascript"> 

    var EventBus = new Vue();

    axios.defaults.xsrfCookieName = 'csrftoken';
    axios.defaults.xsrfHeaderName = 'X-CSRFTOKEN';
    axios.defaults.headers = { "headers": { 'Content-Type': "application/json" } }

    standard_get_api_call = function (url, params, implementationCallback) { 
    // note that we might not need this non-action call, since view should be an action, but we'll use for now
        return axios.post(url, params)
        .then(response => {  implementationCallback(response) }).catch(error => { console.log(error); throw error })
    }

    standard_action_api_call = function (url, params, implementationCallback, dispatch) {
        // Helper method used by API calls which return a single action and throw error if not implemented
        return axios.post(url, params)
        .then(response => {
            dispatch('addOrUpdateAction', { action_pk: response.data.action_pk })
            if (response.data.action_status == "implemented") {
                implementationCallback(response)
            } else {
                throw Error(response.data.action_log)
            }
        }).catch(error => { throw error })
    }

    const store = new Vuex.Store({
        state: {

            // Roles & members
            members: {{ current_members|safe }},    // [ pk, pk, pk, pk ]
            roles: {{ roles|safe }},                // [ 'rolename', 'rolename', 'rolename' ]
            users: {{ users|safe }},                // [ { name: 'username', pk: pk } ]

            // Leadership data
            governance_info: {{ governance_info|safe }},                    // Text string explaining governance structure
            owners: {{ owners|safe }},              // { actors: [pk, pk], roles: ['rolename', 'rolename'] }
            governors: {{ governors|safe }},        // { actors: [pk, pk], roles: ['rolename', 'rolename'] }
            owner_condition_pk: {{ owner_condition_pk|safe }},         // data stored in list of conditions
            governor_condition_pk: {{ governor_condition_pk|safe }},    // data stored in list of conditions 

            // At start, we only load leadership condition data  
            conditions: {{ conditions|safe }},                 // { int(pk) : { name: x, display: x, conditioned_object_pk: x } }         
            condition_configurations: {{ condition_configurations|safe }},   // { int(pk) : { conditionfieldname : conditionfieldvalue } }

            // Permission & condition options   
            permission_options: {{ permission_options|safe }},
                // [ { value: x , text: x } ]
            permission_configuration_options: {{ permission_configuration_options|safe }},
                // { permission_type: { fieldname: { display: x, type: x, required: x, value: x, field_name: x } }
            condition_options: {{ condition_options|safe }},
                // [ { value: x , text: x } ]
            condition_configuration_options: {{ condition_configuration_options|safe }},
                // { condition_type: { fieldname: { display: x, type: x, required: x, value: x, field_name: x } }         

            // Permission data (loaded opportunistically)
            role_permissions: {},             // { role_name: [pk, pk, pk], role_name: [pk, pk, pk] }
            permissions: {},                // { int(pk) : { name: x, display: x, change_type: x } }
            permission_configurations: {},  // { int(pk) : { permissionfieldname : permissionfieldvalue } } 

            // Action history & conditional action data
            actions: {{ actions|safe }},          // We will eventually want to only load some of these
            conditionals: [],
        },
        getters: {
            memberNames: (state, getters) => {
                return state.members.map(member => { return getters.getUserName(member) })
            },
            roleNames: state => {
                names = []
                state.roles.forEach(function(item){ names.push(item.name)})
                return names
            },
            allRoles: (state, getters) => {
                return [{ name: "members", current_members: state.members }].concat(state.roles)
            },
            rolesAsOptions: (state, getters) => {
                return getters.allRoles.map(role => { return {name: role.name } })
            },
            getUser: (state) => (pk) => {
                return state.users.find(user => user.pk == pk)
            },
            getUserName: (state, getters) => (pk) => {
                return getters.getUser(pk).name
            },
            membersInRole: (state, getters) => (role_name) => {
                return state.roles.find(role => role.name == role_name).current_members
            },
            role_to_options: (state, getters) => (role_list) => {
                if (!Array.isArray(role_list)) {
                    role_list = [ role_list ]
                }
                return role_list.map(role => { return  { name: role } })
            },
            user_pk_to_options: (state, getters) => (pk_list) => {
                if (pk_list) {
                    return pk_list.map(pk => { return  { pk: pk, name: getters.getUser(pk).name }  })
                } else {
                    return {}
                }
            },
            groupMembersAsOptions: (state, getters) => { 
                return getters.user_pk_to_options(state.members)
            },
            roleMembersAsOptions: (state, getters) => (role_name) => { 
                role_members = getters.membersInRole(role_name) 
                return getters.user_pk_to_options(role_members)
            },
            membersAsOptions: (state, getters) => (role_name) => { 
                if (role_name == 'members') {  return getters.groupMembersAsOptions  } 
                else {  return getters.roleMembersAsOptions(role_name)  }
            },
            leadershipAsOptions: (state, getters) => {
                return {
                    owner_role_options: state.owners.roles.map(role => { return {name: role } }),
                    owner_actor_options: getters.user_pk_to_options(state.owners.actors),
                    governor_role_options: state.governors.roles.map(role => { return {name: role } }),
                    governor_actor_options: getters.user_pk_to_options(state.governors.actors)
                }
            },
            select_field_is_multiple: (state, getters) => (field) => { 
                if (field.hasOwnProperty("other_data") && field["other_data"].hasOwnProperty("multiple")) {
                    return field["other_data"]["multiple"]
                } else {
                    return true  // By default, select fields allow multiple
                }
            },
            permissionsForRole: (state, getters) => (role_name) => { 
                return state.role_permissions[role_name]
            },
            conditionObjectForPermission: (state, getters) => (permission_pk) => {
                for (key in state.conditions) {
                    if (state.conditions[key].conditioned_object_pk == permission_pk) {
                        return [key, state.conditions[key]]  // really, Javascript?
                    }
                }
            },
            permissionConditionPairs: (state, getters) => (role_name) => { 
                permissions = getters.permissionsForRole(role_name)
                if (permissions) {
                    pairs = []
                    permissions.forEach(function(permission_pk) {
                        condlist = getters.conditionObjectForPermission(permission_pk)
                        if (condlist != undefined) { 
                            condition_data = { id: condlist[0], 
                                display: condlist[1].display } 
                        } else {
                            condition_data = null
                        }
                        permission = state.permissions[permission_pk]
                        pairs.push({ permission: { id: permission_pk, display: permission.display },
                            condition: condition_data })
                    })
                    return pairs
                } else {
                    return []
                }
            },
            getPermissionConfigurationFields: (state, getters) => (permission_type) => {
                // JSON stringify + parse create a new copy of the fields so we don't accidentally mutate state by reference
                return JSON.parse( JSON.stringify( state.permission_configuration_options[permission_type] ))
            },
            getConditionConfigurationFields: (state, getters) => (condition_type) => { 
                for (key in state.condition_configuration_options) {
                    if (key.toLowerCase() == condition_type.toLowerCase()) {
                        configuration = state.condition_configuration_options[key]
                        break
                    }
                }
                // JSON stringify + parse create a new copy of the fields so we don't accidentally mutate state by reference
                return JSON.parse( JSON.stringify( configuration ))
            },
            mapDataToFields: (state, getters) => (fields, existing_data) => {
                new_fields = Object.keys(fields).map(function(field_name) {
                    if (existing_data[field_name]) {
                        fields[field_name].value = existing_data[field_name].value
                        if (fields[field_name].type == "PermissionRoleField") {
                            fields[field_name].value = getters.role_to_options(fields[field_name].value)
                        } else if (fields[field_name].type == "PermissionActorField") {
                            fields[field_name].value = getters.user_pk_to_options(fields[field_name].value)
                        }
                        return fields[field_name]
                    }
                });
                return new_fields
            },
            getConditionConfigurationFieldsWithData: (state, getters) => (condition_id) => { 
                condition = state.conditions[condition_id]
                fields = getters.getConditionConfigurationFields(condition.name)
                condition_configuration_data = state.condition_configurations[condition_id]
                return getters.mapDataToFields(fields, condition_configuration_data)
            },
            getPermissionConfigurationFieldsWithData: (state, getters) => (permission_id) => { 
                permission = state.permissions[permission_id]
                fields = getters.getPermissionConfigurationFields(permission.change_type)
                permission_configuration_data = state.permission_configurations[permission_id]
                return getters.mapDataToFields(fields, permission_configuration_data)
            }
        },
        mutations: {
            ADD_ROLE (state, data) {
                role_exists = state.roles.find(role => role.name == data.role_name)
                if (!role_exists) {
                    state.roles.push({ name: data.role_name, current_members: [] })
                }
            },
            ADD_MEMBERS (state, data ) {
                for (index in data.user_pks) {
                    user_pk = data.user_pks[index]
                    index_of_member = state.members.indexOf(user_pk)
                    if (index_of_member == -1) { state.members.push(user_pk) }
                }
            },
            REMOVE_MEMBERS (state, data) {
                for (index in data.user_pks) {
                    user_pk = data.user_pks[index]
                    index_of_member = state.members.indexOf(user_pk)
                    if (index_of_member > -1) {  state.members.splice(index_of_member, 1) }
                }
            },
            ADD_USERS_TO_ROLE (state, data) {
                role = state.roles.find(role => role.name == data.role_name)
                for (index in data.user_pks) {
                    user_pk = data.user_pks[index]
                    index_of_pk = role.current_members.indexOf(user_pk)
                    if (index_of_pk == -1) { role.current_members.push(user_pk) }
                }                
            },
            REMOVE_USERS_FROM_ROLE (state, data) {
                role = state.roles.find(role => role.name == data.role_name)
                for (index in data.user_pks) {
                    user_pk = data.user_pks[index]
                    index_of_pk = role.current_members.indexOf(user_pk)
                    if (index_of_pk > -1) { role.current_members.splice(index_of_pk, 1) }
                }                 
            },
            REMOVE_USERS_FROM_ALL_ROLES (state, data) {
                state.roles.forEach( function(role){
                    data.user_pks.forEach( function(user_pk) {
                        index_of_user_in_role = role.current_members.indexOf(user_pk)
                        if (index_of_user_in_role > -1 ) { role.current_members.splice(index_of_user_in_role, 1) }
                    })
                })
            },
            ADD_OWNERS (state, data) {
                data.roles_to_add.forEach(function(role){
                    if (!state.owners.roles.includes(role)) { 
                        state.owners.roles.push(role) }
                })
                data.actors_to_add.forEach(function(actor){
                    if (!state.owners.actors.includes(actor)) { 
                        state.owners.actors.push(actor) } 
                })
            },
            REMOVE_OWNERS (state, data) {
                data.roles_to_remove.forEach(function(role){
                    index = state.owners.roles.indexOf(role)
                    if (index > -1) { state.owners.roles.splice(index, 1)}
                })
                data.actors_to_remove.forEach(function(actor){
                    index = state.owners.actors.indexOf(actor)
                    if (index > -1) { state.owners.actors.splice(index, 1)}
                })
            },
            ADD_GOVERNORS (state, data) {
                data.roles_to_add.forEach(function(role){
                    if (!state.governors.roles.includes(role)) { state.governors.roles.push(role) }
                })
                data.actors_to_add.forEach(function(actor){
                    if (!state.governors.actors.includes(actor)) { state.governors.actors.push(actor) }
                })
            },
            REMOVE_GOVERNORS (state, data) {
                data.roles_to_remove.forEach(function(role){
                    index = state.governors.roles.indexOf(role)
                    if (index > -1) { state.governors.roles.splice(index, 1)}
                })
                data.actors_to_remove.forEach(function(actor){
                    index = state.governors.actors.indexOf(actor)
                    if (index > -1) { state.governors.actors.splice(index, 1)}
                })
            },
            ADD_OR_UPDATE_PERMISSION (state, data) {
                Vue.set(state.permissions, data.pk, data.data) // { name: x, display: x, change_type: x } }
            },
            ADD_OR_UPDATE_PERMISSION_CONFIGURATION (state, data) {
                Vue.set(state.permission_configurations, data.pk, data.data) // //  { permissionfieldname : permissionfieldvalue }
            },
            ADD_OR_UPDATE_CONDITION (state, data) {
                // data.data should be a dict with keys name, display, condition_object_pk
                Vue.set(state.conditions, data.pk, data.data) 
            },
            ADD_OR_UPDATE_CONDITION_CONFIGURATION (state, data) {
                // data.data should be an array of fields dicts with keys display, name, value, etc
                Vue.set(state.condition_configurations, data.pk, data.data) 
            },
            ADD_PERMISSION_TO_ROLE (state, data ) {
                permission_index = state.role_permissions[data.role].indexOf(data.pk)
                if (permission_index == -1) { state.role_permissions[data.role].push(data.pk) }
            },
            REMOVE_PERMISSION_FROM_ROLES (state, data ) {
                for (role in state.role_permissions) {
                    permission_index = state.role_permissions[role].indexOf(data.pk)
                    if (permission_index > -1) { 
                        state.role_permissions[role].splice(permission_index, 1) 
                    }
                }
            },
            REPLACE_ROLE_PERMISSIONS (state, data) {
                Vue.set(state.role_permissions, data.role, data.pks)
            },
            DELETE_PERMISSION (state, data) {
                Vue.delete(state.permissions, data.pk);
            },
            DELETE_PERMISSION_CONFIGURATION (state, data) {
                Vue.delete(state.permission_configurations, data.pk);
            },
            DELETE_CONDITION (state, data) {
                Vue.delete(state.conditions, data.pk);
            },
            DELETE_CONDITION_CONFIGURATION (state, data) {
                Vue.delete(state.condition_configurations, data.pk);
            },
            SET_OWNER_CONDITION_PK (state, data) {
                state.owner_condition_pk = data.pk
            },
            SET_GOVERNOR_CONDITION_PK (state, data) {
                state.governor_condition_pk = data.pk
            },
            DELETE_OWNER_CONDITION_PK (state, data) {
                state.owner_condition_pk = null
            },
            DELETE_GOVERNOR_CONDITION_PK (state, data) {
                state.governor_condition_pk = null
            },
            ADD_OR_UPDATE_ACTION (state, data) {
                for (index in state.actions) {
                    if (state.actions[index].action_pk == data.action_data.action_pk) {
                        console.log("A match")
                        console.log("BEfore splice: ", state.actions)
                        state.actions.splice(index, 1, data.action_data)
                        console.log("After splice: ", state.actions)
                        return
                    }
                }
                console.log("Got to push")
                state.actions.push(data.action_data)  // If we get here, we're adding the action
                console.log("After push: ", state.actions)
            }
        },
        actions: {
            addMembers ({ commit, state, dispatch }, payload) { 
                url = "http://127.0.0.1:8000/groups/add_members/{{ object.pk}}/"
                params = { user_pks : payload.user_pks }
                implementationCallback = () => { commit('ADD_MEMBERS', { user_pks: payload.user_pks }) }
                return standard_action_api_call(url, params, implementationCallback, dispatch)
            },
            removeMembers ({ commit, state, dispatch }, payload) { 
                url = "http://127.0.0.1:8000/groups/remove_members/{{ object.pk}}/"
                params = { user_pks : payload.user_pks }
                implementationCallback = () => { 
                    commit('REMOVE_USERS_FROM_ALL_ROLES', { user_pks: payload.user_pks })
                    commit('REMOVE_MEMBERS', { user_pks: payload.user_pks }) 
                }
                return standard_action_api_call(url, params, implementationCallback, dispatch)
            },
            addUsersToRole ({ commit, state, dispatch }, payload) { 
                url = "http://127.0.0.1:8000/groups/add_people_to_role/{{ object.pk}}/"
                params = { role_name : payload.role_name, user_pks: payload.user_pks }
                implementationCallback = () => { commit('ADD_USERS_TO_ROLE', 
                    { role_name : payload.role_name, user_pks: payload.user_pks }) }
                return standard_action_api_call(url, params, implementationCallback, dispatch)
            },
            removeUsersFromRole ({ commit, state, dispatch }, payload) {
                url = "http://127.0.0.1:8000/groups/remove_people_from_role/{{ object.pk}}/"
                params = { role_name : payload.role_name, user_pks: payload.user_pks }
                implementationCallback = () => { commit('REMOVE_USERS_FROM_ROLE', 
                    { role_name : payload.role_name, user_pks: payload.user_pks }) }
                return standard_action_api_call(url, params, implementationCallback, dispatch)
            },
            addRole ({ commit, state, dispatch }, payload) {
                url = "http://127.0.0.1:8000/groups/add_role/{{ object.pk}}/"
                params = { role_name: payload.role_name }
                implementationCallback = () => { commit('ADD_ROLE', { role_name: payload.role_name }) }
                return standard_action_api_call(url, params, implementationCallback, dispatch)
            },
            updateOwners({ commit, state, dispatch}, payload) {
                url = "http://127.0.0.1:8000/groups/update_owners/{{ object.pk}}/"
                params = { owner_roles: payload.roles, owner_actors: payload.actors }
                implementationCallback = () => { 
                    roles_to_add = payload.roles.filter(x => !state.owners.roles.includes(x))
                    actors_to_add = payload.actors.filter(x => !state.owners.actors.includes(x))
                    roles_to_remove = state.owners.roles.filter(x => !payload.roles.includes(x))
                    actors_to_remove = state.owners.actors.filter(x => !payload.actors.includes(x))
                    commit('ADD_OWNERS', { roles_to_add: roles_to_add, actors_to_add: actors_to_add })
                    commit('REMOVE_OWNERS', { roles_to_remove: roles_to_remove, actors_to_remove: actors_to_remove })
                }
                return standard_action_api_call(url, params, implementationCallback, dispatch)
            },
            updateGovernors({ commit, state, dispatch}, payload) {
                url = "http://127.0.0.1:8000/groups/update_governors/{{ object.pk}}/"
                params = { governor_roles: payload.roles, governor_actors: payload.actors }
                implementationCallback = () => { 
                    roles_to_add = payload.roles.filter(x => !state.governors.roles.includes(x))
                    actors_to_add = payload.actors.filter(x => !state.governors.actors.includes(x))
                    roles_to_remove = state.governors.roles.filter(x => !payload.roles.includes(x))
                    actors_to_remove = state.governors.actors.filter(x => !payload.actors.includes(x))
                    commit('ADD_GOVERNORS', { roles_to_add: roles_to_add, actors_to_add: actors_to_add })
                    commit('REMOVE_GOVERNORS', { roles_to_remove: roles_to_remove, actors_to_remove: actors_to_remove })
                }
                return standard_action_api_call(url, params, implementationCallback, dispatch)
            },
            refreshRoleData ({ commit, state }, payload) { 
                url = "http://127.0.0.1:8000/groups/get_data_for_role/{{ object.pk}}/"
                params = { role_name : payload.role }
                implementationCallback = (response) => { 
                    commit('REPLACE_ROLE_PERMISSIONS', { role: payload.role, pks: response.data.role_permissions })
                    for (key in response.data.permissions) { 
                        commit('ADD_OR_UPDATE_PERMISSION', { pk : key, data : response.data.permissions[key] })                    
                    }
                    for (key in response.data.permission_configurations) {
                        commit('ADD_OR_UPDATE_PERMISSION_CONFIGURATION', { pk : key, 
                                                    data : response.data.permission_configurations[key] })                      
                    }
                    for (key in response.data.conditions) {
                        commit('ADD_OR_UPDATE_CONDITION', { pk : key, data : response.data.conditions[key] })
                    }
                    for (key in response.data.condition_configurations) {
                        commit('ADD_OR_UPDATE_CONDITION_CONFIGURATION', { pk : key, 
                                                            data : response.data.condition_configurations[key] })                    
                    }
                }
                return standard_get_api_call(url, params, implementationCallback)
            },
            addPermission ({ commit, state, dispatch }, payload) { 
                url = "http://127.0.0.1:8000/groups/add_permission/{{ object.pk}}/"
                params = { permission_type : payload.permission_selected, permission_roles : payload.role, 
                        permission_configuration : payload.configuration }
                implementationCallback = (response) => { 
                    pk = response.data.permission.pk
                    permission_data = response.data.permission.permission_data[0]
                    configuration_data = response.data.permission.configuration_data[0]
                    commit('ADD_OR_UPDATE_PERMISSION', { pk : pk, data : permission_data })
                    commit('ADD_OR_UPDATE_PERMISSION_CONFIGURATION', { pk : pk, data: configuration_data })
                    commit('ADD_PERMISSION_TO_ROLE', { pk : pk, role: payload.role })
                }
                return standard_action_api_call(url, params, implementationCallback, dispatch)
            },
            updatePermission ({ commit, state, dispatch }, payload) { 
                url = "http://127.0.0.1:8000/groups/update_permission/{{ object.pk}}/"
                params = { permission_id : payload.permission_id, permission_configuration : payload.configuration }
                implementationCallback = (response) => { 
                    pk = response.data.permission.pk
                    permission_data = response.data.permission.permission_data[0]
                    configuration_data = response.data.permission.configuration_data[0]
                    commit('ADD_OR_UPDATE_PERMISSION', { pk : pk, data : permission_data })
                    commit('ADD_OR_UPDATE_PERMISSION_CONFIGURATION', { pk : pk, data: configuration_data })
                }
                return standard_action_api_call(url, params, implementationCallback, dispatch)
            },
            removePermission ({ commit, getters, dispatch }, payload) {  
                url = "http://127.0.0.1:8000/groups/delete_permission/{{ object.pk}}/";
                params = { permission_id : payload.permission_id }
                implementationCallback = (response) => {
                    condlist = getters.conditionObjectForPermission(response.data.removed_permission_pk)
                    if (condlist) {
                        commit('DELETE_CONDITION_CONFIGURATION', { pk: condlist[0] })
                        commit('DELETE_CONDITION', { pk: condlist[0] })        
                    }
                    commit('REMOVE_PERMISSION_FROM_ROLES', { pk: response.data.removed_permission_pk } )
                    commit('DELETE_PERMISSION_CONFIGURATION', { pk: response.data.removed_permission_pk })
                    commit('DELETE_PERMISSION', { pk: response.data.removed_permission_pk })
                }
                return standard_action_api_call(url, params, implementationCallback, dispatch)
            },
            // Conditions
            addCondition ({ commit, state, dispatch }, payload) { 
                url = "http://127.0.0.1:8000/groups/manage_condition/{{ object.pk}}/";
                params = { request_type: "add", condition_type: payload.condition_selected, 
                            target_permission_id: payload.permission, condition_configuration: payload.configuration,
                            target_type: payload.target_type, called_for: payload.called_for }
                implementationCallback = (response) => {
                    pk = response.data.condition_info.pk                   
                    condition_data = response.data.condition_info.condition_data[0]
                    configuration_data = response.data.condition_info.configuration_data[0]
                    commit('ADD_OR_UPDATE_CONDITION', { pk: pk, data: condition_data })
                    commit('ADD_OR_UPDATE_CONDITION_CONFIGURATION', { pk: pk, data: configuration_data })
                    if (payload.called_for == "owner") {
                        commit('SET_OWNER_CONDITION_PK', { pk: pk })
                    }
                    if (payload.called_for == "governor") {
                        commit('SET_GOVERNOR_CONDITION_PK', { pk: pk })
                    }
                }
                return standard_action_api_call(url, params, implementationCallback, dispatch)
            },
            updateCondition ({ commit, state, dispatch }, payload) { 
                url = "http://127.0.0.1:8000/groups/manage_condition/{{ object.pk}}/";
                params = { request_type: "update", condition_id: payload.condition_to_edit, 
                            target_permission_id: payload.permission, condition_configuration: payload.configuration,
                            target_type: payload.target_type} 
                implementationCallback = (response) => {
                    pk = response.data.condition_info.pk
                    condition_data = response.data.condition_info.condition_data[0]
                    configuration_data = response.data.condition_info.configuration_data[0]
                    console.log("Updating condition data", condition_data)
                    console.log("Updating configuration data", configuration_data)
                    commit('ADD_OR_UPDATE_CONDITION', { pk: pk, data: condition_data })
                    commit('ADD_OR_UPDATE_CONDITION_CONFIGURATION', { pk: pk, data: configuration_data })
                }
                return standard_action_api_call(url, params, implementationCallback, dispatch)
            },
            removeCondition ({ commit, state, dispatch }, payload) {  
                url = "http://127.0.0.1:8000/groups/manage_condition/{{ object.pk}}/";
                params = { request_type: "delete", condition_id: payload.condition_id, 
                            target_permission_id: payload.permission_id, target_type: payload.target_type,
                            called_for: payload.called_for }  
                implementationCallback = (response) => {
                    if (payload.called_for == "owner") {
                        commit('DELETE_OWNER_CONDITION_PK', { pk: response.data.deleted_condition_pk })
                    }
                    if (payload.called_for == "governor") {
                        commit('DELETE_GOVERNOR_CONDITION_PK', { pk: response.data.deleted_condition_pk })
                    }   
                    commit('DELETE_CONDITION_CONFIGURATION', { pk: response.data.deleted_condition_pk })
                    commit('DELETE_CONDITION', { pk: response.data.deleted_condition_pk })   
                }
                return standard_action_api_call(url, params, implementationCallback, dispatch)
            },
            addOrUpdateAction ({ commit, state, dispatch}, payload) {
                url = "http://127.0.0.1:8000/groups/get_action_data/";
                params = { action_pk : payload.action_pk }
                implementationCallback = (response) => {
                    commit('ADD_OR_UPDATE_ACTION', { action_data : response.data.action_data })
                }
                return standard_get_api_call(url, params, implementationCallback, dispatch)
            }
        }
    })


    Vue.mixin({
      methods: {
        generate_add_and_remove(old_array, new_array) {
            to_remove = old_array.filter(x => !new_array.includes(x))
            to_add = new_array.filter(x => !old_array.includes(x))
            return { to_add: to_add, to_remove: to_remove }
        },
        prep_axios() {
          axios.defaults.xsrfCookieName = 'csrftoken';
          axios.defaults.xsrfHeaderName = 'X-CSRFTOKEN';
          axios.defaults.headers = { "headers": { 'Content-Type': "application/json" } }
          return axios
        },
        handle_caught_error(error) {
          console.log("ERROR: ", error);
          if (error.response && error.response.status == 500) {
              this.error_message = "We're sorry, there was a problem with our server"
          } else {
              this.error_message = error;
          }
        },
        standard_action_response(response, implementationCallback) {
          if (response.data.action_created) {
            EventBus.$emit('action-created', response.data.action_pk );
          }
          if (response.data.action_status == "implemented") {
            implementationCallback(response)
          } 
          if (response.data.action_status == "waiting" || response.data.action_status == "rejected") {
            this.error_message = response.data.action_log;
          }
        },
        multiple_action_response(response, implementationCallback) {
          if (response.data.action_status == "error") {
            this.error_message = response.data.action_log
          }
          if (response.data.action_status == "success") {
            implementationCallback(response)
          }
          for (index in response.data.actions) {
            if (response.data.actions[index].action_created){
              EventBus.$emit('action-created', response.data.actions[index].action_pk );
            }
          }
        },
        submit_standard_axios_action_call(url, params, implementationCallback) {
            axios = this.prep_axios()
            axios.post(url, params)
            .then(response => { 
                this.standard_action_response(response, implementationCallback)
            }).catch(error => {  this.handle_caught_error(error)  })
        },
        submit_axios_multiple_action_call(url, params, implementationCallback) {
          axios = this.prep_axios()
          axios.post(url, params)
          .then(response => { 
              this.multiple_action_response(response, implementationCallback)
          }).catch(error => {  this.handle_caught_error(error)  })
        }
      }
    })

    
    </script>