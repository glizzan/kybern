

<script type="application/javascript"> 

    const GovernanceVuexModule = { 
        
        state: { 

            // Roles & members
            members: {{ current_members|safe }},    // [ pk, pk, pk, pk ]
            roles: {{ roles|safe }},                // [ 'rolename', 'rolename', 'rolename' ]
            users: {{ users|safe }},                // [ { name: 'username', pk: pk } ]
            current_membership_option: "",         // ie "invite only", "anyone can join"
            membership_config_data: { "permission": null, "condition": null },         // { permission: null, condition: null }

            // Leadership data
            governance_info: {{ governance_info|safe }},                    // Text string explaining governance structure
            owners: {{ owners|safe }},              // { actors: [pk, pk], roles: ['rolename', 'rolename'] }
            governors: {{ governors|safe }},        // { actors: [pk, pk], roles: ['rolename', 'rolename'] }

        },

        mutations: { 
            ADD_ROLE (state, data) {
                role_exists = state.roles.find(role => role.name == data.role_name)
                if (!role_exists) {
                    state.roles.push({ name: data.role_name, current_members: [] })
                }
            },
            ADD_MEMBERS (state, data ) {
                for (index in data.user_pks) {
                    user_pk = data.user_pks[index]
                    index_of_member = state.members.indexOf(user_pk)
                    if (index_of_member == -1) { state.members.push(user_pk) }
                }
            },
            REMOVE_MEMBERS (state, data) {
                for (index in data.user_pks) {
                    user_pk = data.user_pks[index]
                    index_of_member = state.members.indexOf(user_pk)
                    if (index_of_member > -1) {  state.members.splice(index_of_member, 1) }
                }
            },
            ADD_USERS_TO_ROLE (state, data) {
                role = state.roles.find(role => role.name == data.role_name)
                for (index in data.user_pks) {
                    user_pk = data.user_pks[index]
                    index_of_pk = role.current_members.indexOf(user_pk)
                    if (index_of_pk == -1) { role.current_members.push(user_pk) }
                }                
            },
            REMOVE_USERS_FROM_ROLE (state, data) {
                role = state.roles.find(role => role.name == data.role_name)
                for (index in data.user_pks) {
                    user_pk = data.user_pks[index]
                    index_of_pk = role.current_members.indexOf(user_pk)
                    if (index_of_pk > -1) { role.current_members.splice(index_of_pk, 1) }
                }                 
            },
            REMOVE_USERS_FROM_ALL_ROLES (state, data) {
                state.roles.forEach( function(role){
                    data.user_pks.forEach( function(user_pk) {
                        index_of_user_in_role = role.current_members.indexOf(user_pk)
                        if (index_of_user_in_role > -1 ) { role.current_members.splice(index_of_user_in_role, 1) }
                    })
                })
            },
            ADD_OWNERS (state, data) {
                data.roles_to_add.forEach(function(role){
                    if (!state.owners.roles.includes(role)) { 
                        state.owners.roles.push(role) }
                })
                data.actors_to_add.forEach(function(actor){
                    if (!state.owners.actors.includes(actor)) { 
                        state.owners.actors.push(actor) } 
                })
            },
            REMOVE_OWNERS (state, data) {
                data.roles_to_remove.forEach(function(role){
                    index = state.owners.roles.indexOf(role)
                    if (index > -1) { state.owners.roles.splice(index, 1)}
                })
                data.actors_to_remove.forEach(function(actor){
                    index = state.owners.actors.indexOf(actor)
                    if (index > -1) { state.owners.actors.splice(index, 1)}
                })
            },
            ADD_GOVERNORS (state, data) {
                data.roles_to_add.forEach(function(role){
                    if (!state.governors.roles.includes(role)) { state.governors.roles.push(role) }
                })
                data.actors_to_add.forEach(function(actor){
                    if (!state.governors.actors.includes(actor)) { state.governors.actors.push(actor) }
                })
            },
            REMOVE_GOVERNORS (state, data) {
                data.roles_to_remove.forEach(function(role){
                    index = state.governors.roles.indexOf(role)
                    if (index > -1) { state.governors.roles.splice(index, 1)}
                })
                data.actors_to_remove.forEach(function(actor){
                    index = state.governors.actors.indexOf(actor)
                    if (index > -1) { state.governors.actors.splice(index, 1)}
                })
            },
            SET_MEMBERSHIP_OPTION_SELECTED (state, data) {
                state.current_membership_option = data.selection
            },
            SET_MEMBERSHIP_CONFIG_DATA (state, data) {
                Vue.set(state.membership_config_data, "condition", data.condition_data)
                Vue.set(state.membership_config_data, "permission", data.permission_data)
            }

        },

        actions: {
            addMembers ({ commit, state, dispatch }, payload) { 
                url = "{% url 'add_members' target=object.pk %}"    
                params = { user_pks : payload.user_pks }
                implementationCallback = () => { commit('ADD_MEMBERS', { user_pks: payload.user_pks }) }
                return dispatch('actionAPIcall', { url: url, params: params, implementationCallback: implementationCallback})
            },
            removeMembers ({ commit, state, dispatch }, payload) { 
                url = "{% url 'remove_members' target=object.pk %}"    
                params = { user_pks : payload.user_pks }
                implementationCallback = () => { 
                    commit('REMOVE_USERS_FROM_ALL_ROLES', { user_pks: payload.user_pks })
                    commit('REMOVE_MEMBERS', { user_pks: payload.user_pks }) 
                }
                return dispatch('actionAPIcall', { url: url, params: params, implementationCallback: implementationCallback})
            },
            addUsersToRole ({ commit, state, dispatch }, payload) { 
                url = "{% url 'add_people_to_role' target=object.pk %}"    
                params = { role_name : payload.role_name, user_pks: payload.user_pks }
                implementationCallback = () => { commit('ADD_USERS_TO_ROLE', 
                    { role_name : payload.role_name, user_pks: payload.user_pks }) }
                return dispatch('actionAPIcall', { url: url, params: params, implementationCallback: implementationCallback})
            },
            removeUsersFromRole ({ commit, state, dispatch }, payload) {
                url = "{% url 'remove_people_from_role' target=object.pk %}"    
                params = { role_name : payload.role_name, user_pks: payload.user_pks }
                implementationCallback = () => { commit('REMOVE_USERS_FROM_ROLE', 
                    { role_name : payload.role_name, user_pks: payload.user_pks }) }
                return dispatch('actionAPIcall', { url: url, params: params, implementationCallback: implementationCallback})
            },
            addRole ({ commit, state, dispatch }, payload) {
                url = "{% url 'add_role_to_group' target=object.pk %}"    
                params = { role_name: payload.role_name }
                implementationCallback = () => { commit('ADD_ROLE', { role_name: payload.role_name }) }
                return dispatch('actionAPIcall', { url: url, params: params, implementationCallback: implementationCallback})
            },
            updateOwners({ commit, state, dispatch}, payload) {
                url = "{% url 'update_owners' target=object.pk %}"    
                params = { owner_roles: payload.roles, owner_actors: payload.actors }
                implementationCallback = () => { 
                    roles_to_add = payload.roles.filter(x => !state.owners.roles.includes(x))
                    actors_to_add = payload.actors.filter(x => !state.owners.actors.includes(x))
                    roles_to_remove = state.owners.roles.filter(x => !payload.roles.includes(x))
                    actors_to_remove = state.owners.actors.filter(x => !payload.actors.includes(x))
                    commit('ADD_OWNERS', { roles_to_add: roles_to_add, actors_to_add: actors_to_add })
                    commit('REMOVE_OWNERS', { roles_to_remove: roles_to_remove, actors_to_remove: actors_to_remove })
                }
                return dispatch('actionAPIcall', { url: url, params: params, implementationCallback: implementationCallback})
            },
            updateGovernors({ commit, state, dispatch}, payload) {
                url = "{% url 'update_governors' target=object.pk %}"    
                params = { governor_roles: payload.roles, governor_actors: payload.actors }
                implementationCallback = () => { 
                    roles_to_add = payload.roles.filter(x => !state.governors.roles.includes(x))
                    actors_to_add = payload.actors.filter(x => !state.governors.actors.includes(x))
                    roles_to_remove = state.governors.roles.filter(x => !payload.roles.includes(x))
                    actors_to_remove = state.governors.actors.filter(x => !payload.actors.includes(x))
                    commit('ADD_GOVERNORS', { roles_to_add: roles_to_add, actors_to_add: actors_to_add })
                    commit('REMOVE_GOVERNORS', { roles_to_remove: roles_to_remove, actors_to_remove: actors_to_remove })
                }
                return dispatch('actionAPIcall', { url: url, params: params, implementationCallback: implementationCallback})
            }
         },
        getters: { 
            memberNames: (state, getters) => {
                return state.members.map(member => { return getters.getUserName(member) })
            },
            roleNames: state => {
                names = []
                state.roles.forEach(function(item){ names.push(item.name)})
                return names
            },
            allRoles: (state, getters) => {
                return [{ name: "members", current_members: state.members }].concat(state.roles)
            },
            rolesAsOptions: (state, getters) => {
                return getters.allRoles.map(role => { return {name: role.name } })
            },
            getUser: (state) => (pk) => {
                return state.users.find(user => user.pk == pk)
            },
            getUserName: (state, getters) => (pk) => {
                return getters.getUser(pk).name
            },
            membersInRole: (state, getters) => (role_name) => {
                return state.roles.find(role => role.name == role_name).current_members
            },
            role_to_options: (state, getters) => (role_list) => {
                if (!Array.isArray(role_list)) {
                    role_list = [ role_list ]
                }
                return role_list.map(role => { return  { name: role } })
            },
            user_pk_to_options: (state, getters) => (pk_list) => {
                if (pk_list) {
                    return pk_list.map(pk => { return  { pk: pk, name: getters.getUser(pk).name }  })
                } else {
                    return []
                }
            },
            groupMembersAsOptions: (state, getters) => { 
                return getters.user_pk_to_options(state.members)
            },
            roleMembersAsOptions: (state, getters) => (role_name) => { 
                role_members = getters.membersInRole(role_name) 
                return getters.user_pk_to_options(role_members)
            },
            membersAsOptions: (state, getters) => (role_name) => { 
                if (role_name == 'members') {  return getters.groupMembersAsOptions  } 
                else {  return getters.roleMembersAsOptions(role_name)  }
            },
            nonmembersAsOptions: (state, getters) => { 
                return state.users.filter(user => state.members.indexOf(user.pk) == -1 )
            },
            leadershipAsOptions: (state, getters) => {
                return {
                    owner_role_options: state.owners.roles.map(role => { return {name: role } }),
                    owner_actor_options: getters.user_pk_to_options(state.owners.actors),
                    governor_role_options: state.governors.roles.map(role => { return {name: role } }),
                    governor_actor_options: getters.user_pk_to_options(state.governors.actors)
                }
            },

        }

    }

</script>